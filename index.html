<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>アルカディアCR 画像ツール</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        .container {
            display: flex;
            align-items: flex-start;
            gap: 20px;
        }

        canvas {
            border: 1px solid black;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            flex-direction: column;
            gap: 10px;
        }

        .row {
            flex-direction: row;
        }

        .controls button {
            padding: 10px;
            font-size: 16px;
        }

        .tab-menu{
            display:flex;
            list-style:none;
            padding:0;
        }

        .tab-menu li {
            padding: 10px 20px;
            background-color: gray;
            cursor: pointer;
            margin-right: 5px;
            color: white;
        }

        .tab-menu li.active {
            background-color: dodgerblue;
        }

        .tab-content{
            margin-top:0px;
        }

        .tab-content div{
            padding:20px;
            background-color:lightgray;
        }
    </style>
</head>
<body>

    <h1>アルカディアCR 画像ツール</h1>
    <div class="container">
        <canvas id="canvas" width="500" height="500"></canvas>
        <div>
            <div class="controls row">
                <button onclick="saveImage()">PNGで保存</button>
                <button onclick="toggleField()">フィールド切り替え</button>
                <button onclick="resetAoE()">AoEリセット</button>
            </div>

            <div class="tab-container">
                <ul class="tab-menu">
                    <li class="active">キャラ</li>
                    <li>汎用</li>
                    <li>1層</li>
                    <li>2層</li>
                    <li>3層</li>
                    <li>4層</li>
                </ul>
                <div class="tab-content">
                    <div class="controls">
                        <button onclick="toggleEnemyChara()">エネミー表示切り替え</button>
                        <button onclick="togglePlayerChara()">プレイヤー表示切り替え</button>
                        <button onclick="togglePlayerRole()">ロール切り替え</button>
                        <button onclick="resetChara()">キャラ位置リセット</button>
                    </div>
                    <div class="controls" style="display:none;">
                        <button onclick="toggleN()" style="min-width: 80px;">北半面</button>
                        <button onclick="toggleS()" style="min-width: 80px;">南半面</button>
                        <button onclick="toggleW()" style="min-width: 80px;">西半面</button>
                        <button onclick="toggleE()" style="min-width: 80px;">東半面</button>
                    </div>
                    <div class="controls" style="display:none;">
                        <button onclick="toggleBeat()">8ビート/4ビート</button>
                        <button onclick="toggleDiscoInfernal()">ディスコインファーナル</button>
                        <button onclick="toggleFrogDancer()">フロッグダンサー</button>
                        <button onclick="toggleCR1DancingWave()">ダンシングウェーブ</button>
                        <button onclick="toggleCR1DoTheHustle()">ドゥ・ザ・ハッスル</button>
                        <button onclick="toggleDeepCut()">ディープカット +α</button>
                        <button onclick="toggleDancingField()">ダンシングフィールド</button>
                        <button onclick="toggleCircleRing()">インアウト</button>
                        <button onclick="toggleArcadionNightFever()">アルカディアナイトフィーバー</button>
                    </div>
                    <div class="controls" style="display:none;">
                        <button onclick="toggleCR2ColorRiot()">カラーライオット</button>
                        <button onclick="toggleCR2DoubleGraffitiNS()">ダブルグラフィティ北南</button>
                        <button onclick="toggleCR2DoubleGraffitiEW()">ダブルグラフィティ東西</button>
                        <button onclick="toggleCR2SabotenTool()">サボテンツール</button>
                        <button onclick="toggleCR2Saboten()">サボテンパターン</button>
                        <button onclick="toggleCR2Ryusa()">流砂</button>
                    </div>
                    <div class="controls" style="display:none;">
                    </div>
                    <div class="controls" style="display:none;">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let raf;

        const tabs = document.querySelectorAll('.tab-menu li');
        const contents = document.querySelectorAll('.tab-content div');
        tabs.forEach((tab, index) => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                contents.forEach(c => c.style.display = 'none');
                contents[index].style.display = 'flex';

                currentTab = tab.textContent.trim();
            });
        });

        const Enemys = [
            { x: 0, y: 0, radius: 20, text: 'Boss', color: 'purple', dragging: false, visible: true }
        ]

        const Players = [
            { x: 0, y: 0, radius: 15, text: 'Ｍ', color: 'blue', dragging: false, visible: true },
            { x: 0, y: 0, radius: 15, text: 'Ｓ', color: 'blue', dragging: false, visible: true },
            { x: 0, y: 0, radius: 15, text: '１', color: 'green', dragging: false, visible: true },
            { x: 0, y: 0, radius: 15, text: '２', color: 'green', dragging: false, visible: true },
            { x: 0, y: 0, radius: 15, text: '１', color: 'red', dragging: false, visible: true },
            { x: 0, y: 0, radius: 15, text: '２', color: 'red', dragging: false, visible: true },
            { x: 0, y: 0, radius: 15, text: '３', color: 'red', dragging: false, visible: true },
            { x: 0, y: 0, radius: 15, text: '４', color: 'red', dragging: false, visible: true }
        ];

        let SabotenPos = [
            [{ active: false, x: 90, y:  90 }, { active: false, x: 140, y:  90 }, { active: false, x: 250, y:  90 }, { active: false, x: 360, y:  90 }, { active: false, x: 410, y:  90 }],
            [{ active: false, x: 90, y: 170 }, { active: false, x: 170, y: 170 }, { active: false, x: 250, y: 150 }, { active: false, x: 330, y: 170 }, { active: false, x: 410, y: 170 }],
            [{ active: false, x: 90, y: 250 }, { active: false, x: 150, y: 250 }, { active: false, x: 250, y: 250 }, { active: false, x: 350, y: 250 }, { active: false, x: 410, y: 250 }],
            [{ active: false, x: 90, y: 330 }, { active: false, x: 170, y: 330 }, { active: false, x: 250, y: 350 }, { active: false, x: 330, y: 330 }, { active: false, x: 410, y: 330 }],
            [{ active: false, x: 90, y: 410 }, { active: false, x: 140, y: 410 }, { active: false, x: 250, y: 410 }, { active: false, x: 360, y: 410 }, { active: false, x: 410, y: 410 }],
        ];


        const width = canvas.width;
        const height = canvas.height;

        const center = { x: width / 2, y: height / 2 };
        const colors = ["lightgray", "lightpink", "hotpink"];
        const gapSize = 0;
        const segments = [];
        let currentTab = "キャラ";
        let activeDrag = null;
        let playerRoleMode = 0;
        let fieldMode = 0;
        let showN = false;
        let showS = false;
        let showW = false;
        let showE = false;
        let showBeatMode = 0;
        let showDiscoInfernalMode = 0;
        let frogDancerMode = 0;
        let deepCutMode = 0;
        let dancingFieldMode = 0;
        let inOutMode = 0;
        let arcadionNightFeverMode = 0;
        let cr1DancingWaveMode = 0;
        let cr1DoTheHustle = 0;
        let animTime = 0;
        let cr2ColorRiotMode = 0;
        let cr2DoubleGraffitiNSMode = 0;
        let cr2DoubleGraffitiEWMode = 0;
        let cr2SabotenMode = 0;
        let cr2RyusaMode = 0;
        let cr2SabotenToolMode = 0;

        resetAoE();
        resetChara();

        function resetAoE() {
            showN = showS = showW = showE = false;
            showBeatMode = 0;
            showDiscoInfernalMode = 0;
            frogDancerMode = 0;
            deepCutMode = 0;
            dancingFieldMode = 0;
            inOutMode = 0;
            arcadionNightFeverMode = 0;
            cr1DancingWaveMode = 0;
            cr1DoTheHustle = 0;
            cr2ColorRiotMode = 0;
            cr2DoubleGraffitiNSMode = 0;
            cr2DoubleGraffitiEWMode = 0;
            cr2SabotenMode = 0;
            cr2RyusaMode = 0;

            segments.length = 0;
            for (let y = 0; y < 8; y++) {
                segments.push(new Array(8).fill(0));
            }

            SabotenPos.forEach((row) => {
                row.forEach((pos) => {
                    pos.active = false;
                });
            });

            drawImage();
        }

        function resetChara() {
            Enemys[0].x = center.x;
            Enemys[0].y = center.y;
            Players[0].x = center.x + 0;
            Players[0].y = center.y - 100;
            Players[1].x = center.x + 0;
            Players[1].y = center.y + 100;
            Players[2].x = center.x - 100;
            Players[2].y = center.y + 0;
            Players[3].x = center.x + 100;
            Players[3].y = center.y + 0;
            Players[4].x = center.x - 70;
            Players[4].y = center.y - 70;
            Players[5].x = center.x + 70;
            Players[5].y = center.y - 70;
            Players[6].x = center.x - 70;
            Players[6].y = center.y + 70;
            Players[7].x = center.x + 70;
            Players[7].y = center.y + 70;
            drawImage();
        }

        function drawImage() {
            ctx.clearRect(0, 0, width, height);

            drawField();

            drawQuadrants();
            drawBeat();
            drawDiscoInfernal();
            drawFrogDancer();
            drawDeepCut();
            drawCircleRing();
            drawArcadionNightFever();
            drawCR1DancingWave();
            drawCR1DoTheHustle();
            drawCR2ColorRiot();
            drawCR2DoubleGraffiti();
            drawCR2Saboten();


            drawEnemy();
            drawPlayers();
        }

        function drawField() {
            ctx.save();
            switch (fieldMode) {
                case 0:
                    let sW = 400 / 8;
                    for (let x = 0; x < 8; x++) {
                        for (let y = 0; y < 8; y++) {
                            ctx.fillStyle = colors[segments[y][x]];
                            ctx.fillRect(x * sW +50, y * sW +50, sW, sW);
                            ctx.lineWidth = 2;
                            ctx.strokeStyle = "white";
                            ctx.globalCompositeOperation = 'destination-out';
                            ctx.strokeRect(x * sW + 50, y * sW + 50, sW, sW);
                            ctx.globalCompositeOperation = 'source-over';
                        }
                    }
                    break;
                case 1:
                    ctx.fillStyle = colors[0];
                    ctx.fillRect(50, 50, 400, 400);
                    break;
                case 2:
                    ctx.fillStyle = colors[0];
                    ctx.fillRect(150, 50, 200, 400);
                    break;
                case 3:
                    ctx.fillStyle = colors[0];
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, 200, 0, 2 * Math.PI);
                    ctx.fill();
                    break;
            }
            ctx.restore();
        }

        function drawPlayers() {
            ctx.save();
            Players.forEach((chara) => { 
                if (!chara.visible) return;

                drawCircleStroke(chara, chara.radius, playerRoleMode !== 2 ? chara.color : 'gray', 2, 'darkgoldenrod');

                if (playerRoleMode === 0) {
                    ctx.fillStyle = 'white';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(chara.text, chara.x, chara.y);
                }
            });
            ctx.restore();
        }

        function drawEnemy() {
            ctx.save();
            const enemy = Enemys[0];
            if (!enemy.visible) return;
            drawCircleStroke(enemy, enemy.radius, enemy.color, 2, 'darkgoldenrod');
            ctx.fillStyle = 'white';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(enemy.text, enemy.x, enemy.y);
            ctx.restore();
        }

        function toggleN() {
            showN = !showN;
            drawImage();
        }

        function toggleS() {
            showS = !showS;
            drawImage();
        }

        function toggleW() {
            showW = !showW;
            drawImage();
        }

        function toggleE() {
            showE = !showE;
            drawImage();
        }

        function drawQuadrants() {
            const halfW = width / 2;
            const halfH = height / 2;
            if (showE) drawRectFromAngle({ x: halfW, y: halfH }, Math.PI * 0 / 2, width, halfH, 'orange', 0.2);
            if (showS) drawRectFromAngle({ x: halfW, y: halfH }, Math.PI * 1 / 2, width, halfH, 'orange', 0.2);
            if (showW) drawRectFromAngle({ x: halfW, y: halfH }, Math.PI * 2 / 2, width, halfH, 'orange', 0.2);
            if (showN) drawRectFromAngle({ x: halfW, y: halfH }, Math.PI * 3 / 2, width, halfH, 'orange', 0.2);
        }

        function toggleBeat() {
            showBeatMode++;
            drawImage();
        }

        function drawBeat() {
            showBeatMode %= 4;
            if (showBeatMode === 0) return;
            if (showBeatMode === 1) [0, 1, 2, 3, 4, 5, 6, 7].forEach((t) => { drawCircle(Players[t], 50, 'orange', 0.5); });
            if (showBeatMode === 2) [0, 1, 2, 3].forEach((t) => { drawCircle(Players[t], 40, 'orange', 0.5); });
            if (showBeatMode === 3) [4, 5, 6, 7].forEach((t) => { drawCircle(Players[t], 40, 'orange', 0.5); });
        }

        function toggleDiscoInfernal() {
            showDiscoInfernalMode++;
            drawImage();
        }

        function drawDiscoInfernal() {
            showDiscoInfernalMode %= 5;
            if (showDiscoInfernalMode === 0) return;

            const patterns = [[
                { x: 175, y: 225},
                { x: 325, y: 275},
                { x: 225, y: 325},
                { x: 275, y: 175},
                { x: 125, y: 125},
                { x: 125, y: 375},
                { x: 375, y: 125},
                { x: 375, y: 375},
            ], [
                { x: 325, y: 225},
                { x: 175, y: 275},
                { x: 225, y: 175},
                { x: 275, y: 325},
                { x: 375, y: 125},
                { x: 125, y: 125},
                { x: 375, y: 375},
                { x: 125, y: 375},
            ], [
                { x: 100, y: 250 },
                { x: 250, y: 100 },
                { x: 250, y: 400 },
                { x: 400, y: 250 },
            ], [
                { x: 100, y: 100 },
                { x: 400, y: 100 },
                { x: 400, y: 400 },
                { x: 100, y: 400 },
            ]];

            patterns[showDiscoInfernalMode - 1].forEach((pattern) => { drawCircle(pattern, 25, 'blue', 0.5); });
        }

        function toggleFrogDancer() {
            frogDancerMode++;
            drawImage();
        }

        function drawFrogDancer() {
            frogDancerMode = frogDancerMode % 7;
            if (frogDancerMode === 0) return;

            const patterns = [
                [
                    { x: 50 * 5, y: 50 * 4, angle: Math.PI * 1 / 2 },
                    { x: 50 * 5, y: 50 * 6, angle: Math.PI * 3 / 2 },
                ], [
                    { x: 50 * 4, y: 50 * 5, angle: Math.PI * 4 / 2 },
                    { x: 50 * 6, y: 50 * 5, angle: Math.PI * 2 / 2 },
                ], [
                    { x: 50 * 5, y: 50 * 4, angle: Math.PI * 3 / 2 },
                    { x: 50 * 5, y: 50 * 6, angle: Math.PI * 1 / 2 },
                ], [
                    { x: 50 * 4, y: 50 * 5, angle: Math.PI * 2 / 2 },
                    { x: 50 * 6, y: 50 * 5, angle: Math.PI * 4 / 2 },
                ], [
                    { x: 50 * 4, y: 50 * 5, angle: Math.PI * 4 / 2 },
                    { x: 50 * 6, y: 50 * 5, angle: Math.PI * 2 / 2 },
                    { x: 50 * 5, y: 50 * 4, angle: Math.PI * 3 / 2 },
                    { x: 50 * 5, y: 50 * 6, angle: Math.PI * 1 / 2 },
                ], [
                    { x: 50 * 5, y: 50 * 4, angle: Math.PI * 1 / 2 },
                    { x: 50 * 5, y: 50 * 6, angle: Math.PI * 3 / 2 },
                    { x: 50 * 4, y: 50 * 5, angle: Math.PI * 2 / 2 },
                    { x: 50 * 6, y: 50 * 5, angle: Math.PI * 4 / 2 },
                ]
            ];

            patterns[frogDancerMode - 1].forEach((p) => { drawRectFromAngle(p, p.angle, 400, 150, 'orange', 0.3); });
        }

        function toggleDeepCut() {
            deepCutMode++;
            drawImage();
        }

        function drawDeepCut() {
            deepCutMode = deepCutMode % 5;
            if (deepCutMode === 0) return;

            const patterns = [
                [0, 1],
                [0, 1, 2, 3],
                [4, 5, 6, 7],
                [0, 1, 2, 3, 4, 5, 6, 7]
            ];
            patterns[deepCutMode - 1].forEach((p) => { drawFanFromAtoB(Enemys[0], Players[p], 400, Math.PI / 4, 'red', 0.5); });
        }

        function toggleCircleRing() {
            inOutMode = (inOutMode + 1) % 3;
            drawImage();
        }

        function drawCircleRing() {
            if (inOutMode === 0) return;

            if (inOutMode === 1) {
                drawCircle(center, 70, 'olive', 0.5);
            } else if (inOutMode === 2) {
                drawRing(center, 50, 400, 'olive', 0.5);
            }
        }

        function toggleArcadionNightFever() {
            arcadionNightFeverMode = (arcadionNightFeverMode + 1) % 9;
            drawImage();
        }

        function drawArcadionNightFever() {
            if (arcadionNightFeverMode === 0) return;
            const targets = [0, 4, 1, 5, 2, 6, 3, 7, 0];
            drawFanFromAtoB(Enemys[0], Players[targets[arcadionNightFeverMode-1]], 400, Math.PI / 4, 'red', 0.5);
            drawFanFromAtoB(Enemys[0], Players[targets[arcadionNightFeverMode]], 400, Math.PI / 4, 'red', 0.5);
        }

        function toggleCR1DancingWave() {
            cr1DancingWaveMode++;
            drawImage();
        }

        function drawCR1DancingWave() {
            cr1DancingWaveMode %= 3;
            if (cr1DancingWaveMode === 0) return;
            const patterns = [[
                { x: 200, y: 200 },
                { x: 200, y: 300 },
                { x: 300, y: 200 },
                { x: 300, y: 300 },
            ], [
                { x: 250, y: 180 },
                { x: 180, y: 250 },
                { x: 320, y: 250 },
                { x: 250, y: 320 },
            ]];

            patterns[cr1DancingWaveMode - 1].forEach((pattern) => { drawFanFromAtoB(pattern, getClosestPlayers(pattern)[0], 400, Math.PI / 4, 'gray', 0.5); });
        }

        function toggleCR1DoTheHustle() {
            cr1DoTheHustle++;
            drawImage();
        }

        function drawCR1DoTheHustle() {
            cr1DoTheHustle = cr1DoTheHustle % 5;
            if (cr1DoTheHustle === 0) return;
            const patterns = [
                { x: 200, y: 200 },
                { x: 200, y: 300 },
                { x: 300, y: 300 },
                { x: 300, y: 200 }
            ];

            drawRectFromAtoB({ x: 250, y: 250 }, patterns[cr1DoTheHustle-1], 700, 400, 'orange', 0.2);
            drawRectFromAtoB({ x: 250, y: 250 }, patterns[(cr1DoTheHustle)%4], 700, 400, 'orange', 0.2);
        }

        function toggleDancingField() {
            dancingFieldMode = (dancingFieldMode + 1) % 3;

            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    if (dancingFieldMode === 1) {
                        segments[y][x] = (x + y) % 2;
                    } else if (dancingFieldMode === 2) {
                        segments[y][x] = (x + y + 1) % 2;
                    } else {
                        segments[y][x] = 0;
                    }
                }
            }

            drawImage();
        }

        function toggleDancingFieldAnim() {
            resetAoE();
            animTime = 0;
            raf = window.requestAnimationFrame(drawDancingFieldAnim);

        }

        function drawDancingFieldAnim(timestamp) {
            if (animTime === 0) animTime = timestamp;
            const frame = timestamp - animTime;

            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    if ((frame % 7000) < 1500) {
                        segments[y][x] = (x + y) % 2;
                    } else if ((frame % 7000) < 2500) {
                        segments[y][x] = ((x + y) % 2) * 2;
                    } else if ((frame % 7000) < 3500) {
                        segments[y][x] = 0;

                    } else if ((frame % 7000) < 5000) {
                        segments[y][x] = (x + y + 1) % 2;
                    } else if ((frame % 7000) < 6000) {
                        segments[y][x] = ((x + y + 1) % 2) * 2;
                    } else if ((frame % 7000) < 7000) {
                        segments[y][x] = 0;
                    }
                }
            }

            if (frame < 8500) {
                inOutMode = 0;
            } else if (frame < 9500) {
                inOutMode = 1;
            } else if (frame < 10500) {
                inOutMode = 0;
            } else if (frame < 11500) {
                inOutMode = 2;
            } else {
                inOutMode = 0;
            }

            const patterns = [
                { x: 175, y: 225 },
                { x: 325, y: 275 },
                { x: 225, y: 325 },
                { x: 275, y: 175 },
                { x: 125, y: 125 },
                { x: 125, y: 375 },
                { x: 375, y: 125 },
                { x: 375, y: 375 },
            ]


            drawImage();
            patterns.forEach((pattern) => { drawCircle(pattern, 25, 'blue', 0.5); });

            if (frame < 30000) {
                raf = window.requestAnimationFrame(drawDancingFieldAnim);
            }
        }

        function toggleCR2ColorRiot() {
            cr2ColorRiotMode++;
            drawImage();
        }

        function drawCR2ColorRiot() {
            cr2ColorRiotMode = cr2ColorRiotMode % 3;
            if (cr2ColorRiotMode === 0) return;
            const p = getClosestPlayers(center)
            drawCircle(p[0], 50, cr2ColorRiotMode>1?"red":"blue", 0.5);
            drawCircle(p[7], 50, cr2ColorRiotMode>1?"blue":"red", 0.5);
        }

        function toggleCR2DoubleGraffitiNS() {
            cr2DoubleGraffitiNSMode++;
            drawImage();
        }

        function toggleCR2DoubleGraffitiEW() {
            cr2DoubleGraffitiEWMode++;
            drawImage();
        }

        function drawCR2DoubleGraffiti() {
            cr2DoubleGraffitiNSMode = cr2DoubleGraffitiNSMode % 5;
            cr2DoubleGraffitiEWMode = cr2DoubleGraffitiEWMode % 7;

            if (cr2DoubleGraffitiNSMode === 1) drawFanFromAtoB({ x: 250, y: 50 }, center, 500, Math.PI / 1.9, 'orange', 0.2);
            if (cr2DoubleGraffitiNSMode === 2) drawFanFromAtoB({ x: 250, y: 450 }, center, 500, Math.PI / 1.9, 'orange', 0.2);
            if (cr2DoubleGraffitiNSMode === 3) drawCircle({ x: 250, y: 50 }, 300, 'orange', 0.2);
            if (cr2DoubleGraffitiNSMode === 4) drawCircle({ x: 250, y: 450 }, 300, 'orange', 0.2);

            if (cr2DoubleGraffitiEWMode === 1) drawFanFromAtoB({ x: 50, y: 250 }, center, 500, Math.PI / 1.9, 'orange', 0.2);
            if (cr2DoubleGraffitiEWMode === 2) drawFanFromAtoB({ x: 450, y: 250 }, center, 500, Math.PI / 1.9, 'orange', 0.2);
            if (cr2DoubleGraffitiEWMode === 3) drawCircle({ x: 50, y: 250 }, 300, 'orange', 0.2);
            if (cr2DoubleGraffitiEWMode === 4) drawCircle({ x: 450, y: 250 }, 300, 'orange', 0.2);

            if (cr2DoubleGraffitiEWMode === 5) {
                drawCircle({ x: 330, y: 80 }, 150, 'orange', 0.2);
                drawCircle({ x: 330, y: 250 }, 150, 'orange', 0.2);
                drawCircle({ x: 330, y: 420 }, 150, 'orange', 0.2);
            }
            if (cr2DoubleGraffitiEWMode === 6) {
                drawCircle({ x: 170, y: 80 }, 150, 'orange', 0.2);
                drawCircle({ x: 170, y: 250 }, 150, 'orange', 0.2);
                drawCircle({ x: 170, y: 420 }, 150, 'orange', 0.2);
            }
        }

        function toggleCR2Saboten() {
            cr2SabotenMode++;
            cr2SabotenMode = cr2SabotenMode % 12;

            SabotenPos.forEach((row) => {
                row.forEach((pos) => {
                    pos.active = false;
                });
            });

            if (cr2SabotenMode > 0) {
                const patterns = [
                    [{ y: 3, x: 0 }, { y: 2, x: 1 }, { y: 0, x: 3 }, { y: 4, x: 3 }, { y: 1, x: 4 }],
                    [{ y: 1, x: 0 }, { y: 4, x: 0 }, { y: 2, x: 2 }, { y: 3, x: 2 }, { y: 0, x: 4 }],
                    [{ y: 3, x: 1 }, { y: 0, x: 2 }, { y: 1, x: 2 }, { y: 2, x: 4 }, { y: 4, x: 4 }],
                    [{ y: 0, x: 0 }, { y: 2, x: 0 }, { y: 4, x: 1 }, { y: 1, x: 3 }, { y: 3, x: 3 }],
                    [{ y: 0, x: 1 }, { y: 1, x: 1 }, { y: 4, x: 2 }, { y: 2, x: 3 }, { y: 3, x: 4 }],
                    [{ y: 4, x: 0 }, { y: 0, x: 1 }, { y: 2, x: 2 }, { y: 1, x: 3 }, { y: 3, x: 3 }],
                    [{ y: 0, x: 0 }, { y: 1, x: 2 }, { y: 3, x: 3 }, { y: 2, x: 4 }, { y: 4, x: 4 }],
                    [{ y: 1, x: 1 }, { y: 4, x: 2 }, { y: 0, x: 3 }, { y: 1, x: 4 }, { y: 3, x: 4 }],
                    [{ y: 4, x: 0 }, { y: 3, x: 1 }, { y: 1, x: 2 }, { y: 2, x: 3 }, { y: 0, x: 4 }],
                    [{ y: 1, x: 0 }, { y: 2, x: 0 }, { y: 3, x: 0 }, { y: 0, x: 2 }, { y: 4, x: 3 }],
                    [{ y: 4, x: 0 }, { y: 0, x: 1 }, { y: 1, x: 3 }, { y: 3, x: 3 }, { y: 2, x: 4 }],
                ];

                patterns[cr2SabotenMode - 1].forEach((pattern) => {
                    SabotenPos[pattern.y][pattern.x].active = true;
                });
            }

            drawImage();
        }

        function toggleCR2Ryusa() {
            cr2RyusaMode++;
            cr2RyusaMode = cr2RyusaMode % 3;

            SabotenPos.forEach((row) => {
                row.forEach((pos) => {
                    pos.active = false;
                });
            });


            if (cr2RyusaMode === 1) {
                const ryusaPattern = [
                    [{ y: 1, x: 0 }, { y: 4, x: 0 }, { y: 2, x: 1 }, { y: 4, x: 1 }, { y: 1, x: 2 }, { y: 3, x: 2 }, { y: 0, x: 3 }, { y: 2, x: 3 }, { y: 1, x: 4 }, { y: 3, x: 4 }],
                ];

                ryusaPattern[cr2RyusaMode - 1].forEach((pattern) => {
                    SabotenPos[pattern.y][pattern.x].active = true;
                });
            }

            drawImage();
        }

        function toggleCR2SabotenTool() {
            cr2SabotenToolMode++;
            cr2SabotenToolMode = cr2SabotenToolMode % 2;

            SabotenPos.forEach((row) => {
                row.forEach((pos) => {
                    pos.active = false;
                });
            });

            drawImage();
        }

        function drawCR2Saboten() {
            if (cr2RyusaMode === 1) {
                drawCircle(center, 225, 'brown', 0.2);
            }

            if (cr2RyusaMode === 2) {
                drawCircle({ x: 60, y: 250 }, 225, 'brown', 0.2);

                Players.forEach((p) => {
                    drawCircle(p, 150, 'orange', 0.2);
                });

            }

            if (cr2SabotenMode > 0 || cr2RyusaMode === 1 || cr2SabotenToolMode > 0) {
                SabotenPos.forEach((row) => {
                    row.forEach((pos) => {
                        if (pos.active) {
                            drawCircle(pos, 100, 'orange', 0.3);
                            drawCircle(pos, 10, 'green', 0.2);
                        } else {
                            drawCircle(pos, 5, 'green', 0.2);
                        }
                    });
                });
            }
        }

        canvas.addEventListener("click", (event) => {
            if (currentTab === "キャラ") return;

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            if (cr2SabotenMode > 0 || cr2RyusaMode === 1 || cr2SabotenToolMode > 0) {
                SabotenPos.forEach((row) => {
                    row.forEach((pos) => {
                        const dx = x - pos.x;
                        const dy = y - pos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // サボテンのクリック判定 (半径10以内)
                        if (distance <= 20) {
                            pos.active = !pos.active; // active状態を切り替え
                            drawImage(); // 再描画
                        }
                    });
                });
                return; // サボテンツールモードの場合は他の処理をスキップ
            }

            const segmentSize = 400 / 8;
            const gridX = Math.floor((x - 50) / segmentSize);
            const gridY = Math.floor((y - 50) / segmentSize);

            if (gridX >= 0 && gridX < 8 && gridY >= 0 && gridY < 8) {
                segments[gridY][gridX] = (segments[gridY][gridX] + 1) % colors.length;
                drawImage();
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (currentTab !== "キャラ") return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            let characters = Players.concat(Enemys);
            for (const chara of characters) {
                if (!chara.visible) continue;
                const dx = x - chara.x;
                const dy = y - chara.y;
                if (Math.sqrt(dx * dx + dy * dy) <= chara.radius) {
                    chara.dragging = true;
                    activeDrag = chara;
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!activeDrag) return;
            const rect = canvas.getBoundingClientRect();
            activeDrag.x = e.clientX - rect.left;
            activeDrag.y = e.clientY - rect.top;
            drawImage();
        });

        canvas.addEventListener('mouseup', () => {
            if (activeDrag) activeDrag.dragging = false;
            activeDrag = null;
        });

        canvas.addEventListener('mouseleave', () => {
            if (activeDrag) activeDrag.dragging = false;
            activeDrag = null;
        });

        function toggleField() {
            fieldMode = (fieldMode + 1) % 4;
            drawImage();
        }
        function toggleEnemyChara() {
            Enemys[0].visible = !Enemys[0].visible;
            drawImage();
        }

        function togglePlayerChara() {
            Players.forEach((chara) => {chara.visible = !chara.visible;});
            drawImage();
        }

        function togglePlayerRole() {
            playerRoleMode = (playerRoleMode + 1) % 3;
            drawImage();
        }

        function toggleCharaLock() {
            for (let i = 0; i < Players.length; i++) {
                Players[i].dragging = !Players[i].dragging;
            }
            drawImage();
        }

        function toDScale(c) {
            return c * 5 + center.x;
        }

        function drawCircle(from, radius, color, alpha = 1) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(from.x, from.y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }

        function drawCircleStroke(from, radius, color, lineWidth, lineColor) {
            ctx.save();
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(from.x, from.y, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = lineColor;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
            ctx.restore();
        }

        function drawRing(from, innerRadius, outerRadius, color, alpha = 1) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(from.x, from.y, outerRadius, 0, 2 * Math.PI);
            ctx.arc(from.x, from.y, innerRadius, 0, 2 * Math.PI, true);
            ctx.fill();
            ctx.restore();
        }

        function drawFanFromAtoB(from, to, radius, widthAngle, color, alpha = 1) {
            drawFanFromAngle(from, Math.atan2(to.y - from.y, to.x - from.x), radius, widthAngle, color, alpha);
        }

        function drawFanFromAngle(from, angle, radius, widthAngle, color, alpha = 1) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.arc(from.x, from.y, radius, angle - widthAngle / 2, angle + widthAngle / 2);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawRectFromAtoB(from, to, width, length, color, alpha = 1) {
            drawRectFromAngle(from, Math.atan2(to.y - from.y, to.x - from.x), width, length, color, alpha);
        }

        function drawRectFromAngle(from, angle, width, length, color, alpha = 1) {
            const halfWidth = width / 2;
            const dx = Math.cos(angle) * length;
            const dy = Math.sin(angle) * length;
            const p1 = { x: from.x - Math.sin(angle) * halfWidth, y: from.y + Math.cos(angle) * halfWidth };
            const p2 = { x: from.x + Math.sin(angle) * halfWidth, y: from.y - Math.cos(angle) * halfWidth };
            const p3 = { x: p2.x + dx, y: p2.y + dy };
            const p4 = { x: p1.x + dx, y: p1.y + dy };

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.lineTo(p4.x, p4.y);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function getClosestPlayers(pos) {
            return Players
                .map(player => {
                    const dx = player.x - pos.x;
                    const dy = player.y - pos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return { player, distance };
                })
                .sort((a, b) => a.distance - b.distance) // 距離でソート
                .map(entry => entry.player); // プレイヤーオブジェクトのみを返す
        }

        function saveImage() {
            const link = document.createElement("a");
            link.download = "arcadionCR.png";
            link.href = canvas.toDataURL();
            link.click();
        }


    </script>

</body>
</html>
